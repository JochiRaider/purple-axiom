# Tier-3 identity basis for osquery events (no upstream record id).
# The mapping engine MUST compute metadata.event_id from this basis deterministically.

identity:
  source_type: osquery

  # Derive stable routing + identity fields.
  fields:
    host_identifier:
      coalesce: [hostIdentifier, osquery.host_identifier]
      transforms: [trim]

    query_name:
      coalesce: [name, osquery.query_name]
      transforms: [trim]

    action:
      coalesce: [action, osquery.action]
      transforms: [trim, lowercase]

    unix_time:
      coalesce: [unixTime, osquery.unix_time]
      transforms: [trim, parse_int_base10]

  # Payload basis:
  # - If columns is present: payload = canonical(columns)
  # - If snapshot is present: payload = canonical(row) for each expanded row
  payload:
    columns:
      selector: columns
      transforms: [canonical_json_jcs]
    snapshot:
      selector: snapshot
      transforms: [sort_by_jcs_bytes]

  # Snapshot expansion rule:
  # - If action == snapshot and snapshot[] exists:
  #   emit one normalized event per snapshot row, using canonical(row) as payload.
  snapshot_expansion:
    when:
      all:
        - present: snapshot
        - equals:
            selector: action
            value: snapshot
            case_insensitive: true
    mode: expand_rows
    row_payload_transform: canonical_json_jcs
    row_sort_transform: sort_by_jcs_bytes

  # Hash algorithm for event_id.
  # The engine MUST hash the canonical JSON form of the identity basis object.
  event_id_hash:
    algorithm: sha256
    input_transform: canonical_json_jcs
    output_encoding: hex_lower

  # Disallowed fields for identity (must be ignored even if present).
  exclude_from_identity:
    - calendarTime
    - osquery.calendar_time
