{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "urn:purple-axiom:contract:telemetry_intent:1.0.0",
  "title": "Telemetry intent (effective)",
  "description": "Effective telemetry intent for a run. This artifact enumerates the telemetry sources expected to be collected for the run, derived from telemetry.* configuration and resolved lab asset scope. Deterministic ordering rules are specified in the telemetry pipeline spec (arrays must be emitted in stable, lexicographic order; this schema does not enforce ordering).",
  "type": "object",
  "additionalProperties": false,
  "required": ["contract_version", "run_id", "generated_at_utc", "telemetry_enabled", "sources"],
  "properties": {
    "contract_version": {
      "type": "string",
      "const": "1.0.0",
      "description": "Contract version constant. Must match the contract_registry-declared version."
    },
    "run_id": {
      "$ref": "#/$defs/run_id"
    },
    "generated_at_utc": {
      "$ref": "#/$defs/timestamp_utc"
    },
    "telemetry_enabled": {
      "type": "boolean",
      "description": "Whether telemetry collection is enabled for this run. When false, sources must be an empty array."
    },
    "sources": {
      "type": "array",
      "description": "Enumerated telemetry sources expected for this run. Emit one entry per reportable source_type (aligned to metadata.source_type), even when collection is performed by a multi-channel collector.",
      "items": {
        "$ref": "#/$defs/telemetry_source_intent"
      }
    },
    "extensions": {
      "$ref": "#/$defs/extensions"
    }
  },
  "allOf": [
    {
      "if": {
        "properties": { "telemetry_enabled": { "const": false } },
        "required": ["telemetry_enabled"]
      },
      "then": {
        "properties": {
          "sources": {
            "type": "array",
            "maxItems": 0
          }
        }
      },
      "else": {
        "properties": {
          "sources": {
            "type": "array",
            "minItems": 1
          }
        }
      }
    }
  ],
  "$defs": {
    "run_id": {
      "type": "string",
      "description": "RFC 4122 UUID in canonical hyphenated form, lowercase hex.",
      "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    },
    "timestamp_utc": {
      "type": "string",
      "description": "UTC timestamp string in RFC 3339 form with Z suffix (fractional seconds allowed).",
      "pattern": "^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,9})?Z$"
    },
    "source_type": {
      "type": "string",
      "description": "Reportable source type token. Must align to normalized event metadata.source_type values. Lower snake case.",
      "pattern": "^[a-z][a-z0-9_]*$",
      "minLength": 1
    },
    "asset_id": {
      "type": "string",
      "description": "Stable Purple Axiom logical asset identifier (lab.assets[].asset_id).",
      "minLength": 1
    },
    "otel_receiver_id": {
      "type": "string",
      "description": "Stable OpenTelemetry receiver instance identifier (for example: windowseventlog/security, filelog/osquery).",
      "pattern": "^([a-z][a-z0-9_]*)(/[a-z][a-z0-9_]*)*$",
      "minLength": 1
    },
    "channel_token": {
      "type": "string",
      "description": "Canonical channel token (lower snake case) used for enumerated sources (for example: security, system, application, sysmon).",
      "pattern": "^[a-z][a-z0-9_]*$",
      "minLength": 1
    },
    "telemetry_source_intent": {
      "type": "object",
      "additionalProperties": false,
      "required": ["source_type", "assets", "collection"],
      "properties": {
        "source_type": {
          "$ref": "#/$defs/source_type"
        },
        "assets": {
          "type": "array",
          "description": "Assets where this source is expected to be collected. Must be emitted in deterministic order by asset_id.",
          "minItems": 1,
          "items": {
            "$ref": "#/$defs/source_asset_scope"
          }
        },
        "collection": {
          "description": "How this telemetry source is collected. The kind determines which fields are present.",
          "oneOf": [
            { "$ref": "#/$defs/collection_windows_eventlog" },
            { "$ref": "#/$defs/collection_filelog" },
            { "$ref": "#/$defs/collection_syslog" },
            { "$ref": "#/$defs/collection_otlp" },
            { "$ref": "#/$defs/collection_custom" }
          ]
        },
        "extensions": {
          "$ref": "#/$defs/extensions"
        }
      }
    },
    "source_asset_scope": {
      "type": "object",
      "additionalProperties": false,
      "required": ["asset_id"],
      "properties": {
        "asset_id": {
          "$ref": "#/$defs/asset_id"
        },
        "extensions": {
          "$ref": "#/$defs/extensions"
        }
      }
    },
    "collection_windows_eventlog": {
      "type": "object",
      "additionalProperties": false,
      "required": ["kind", "receiver_id", "channel", "raw_required"],
      "properties": {
        "kind": {
          "type": "string",
          "const": "windows_eventlog"
        },
        "receiver_id": {
          "$ref": "#/$defs/otel_receiver_id"
        },
        "channel": {
          "$ref": "#/$defs/channel_token"
        },
        "raw_required": {
          "type": "boolean",
          "description": "Whether raw, unrendered event capture is required for this source (expected true for Windows Event Log channels)."
        },
        "extensions": {
          "$ref": "#/$defs/extensions"
        }
      }
    },
    "collection_filelog": {
      "type": "object",
      "additionalProperties": false,
      "required": ["kind", "paths"],
      "properties": {
        "kind": {
          "type": "string",
          "const": "filelog"
        },
        "receiver_id": {
          "$ref": "#/$defs/otel_receiver_id"
        },
        "paths": {
          "type": "array",
          "description": "File paths expected to be tailed/ingested for this source (platform-specific paths allowed). Emit in deterministic order.",
          "minItems": 1,
          "items": {
            "type": "string",
            "minLength": 1
          }
        },
        "record_format": {
          "type": "string",
          "description": "Expected record format for the tailed content.",
          "enum": ["ndjson", "jsonl", "text", "unknown"]
        },
        "extensions": {
          "$ref": "#/$defs/extensions"
        }
      }
    },
    "collection_syslog": {
      "type": "object",
      "additionalProperties": false,
      "required": ["kind"],
      "properties": {
        "kind": {
          "type": "string",
          "const": "syslog"
        },
        "receiver_id": {
          "$ref": "#/$defs/otel_receiver_id"
        },
        "transport": {
          "type": "string",
          "description": "Syslog transport when known.",
          "enum": ["udp", "tcp", "tls", "unknown"]
        },
        "extensions": {
          "$ref": "#/$defs/extensions"
        }
      }
    },
    "collection_otlp": {
      "type": "object",
      "additionalProperties": false,
      "required": ["kind"],
      "properties": {
        "kind": {
          "type": "string",
          "const": "otlp"
        },
        "protocol": {
          "type": "string",
          "description": "OTLP protocol when known.",
          "enum": ["http", "grpc", "unknown"]
        },
        "extensions": {
          "$ref": "#/$defs/extensions"
        }
      }
    },
    "collection_custom": {
      "type": "object",
      "additionalProperties": false,
      "required": ["kind", "name"],
      "properties": {
        "kind": {
          "type": "string",
          "const": "custom"
        },
        "name": {
          "type": "string",
          "description": "Custom collector name or integration identifier (lower snake case recommended).",
          "minLength": 1
        },
        "extensions": {
          "$ref": "#/$defs/extensions"
        }
      }
    },
    "extensions": {
      "type": "object",
      "description": "Forward-compatible extension point. Namespaces must be lower_snake_case and should be objects.",
      "default": {},
      "propertyNames": {
        "pattern": "^[a-z][a-z0-9_]*$"
      },
      "additionalProperties": {
        "type": "object",
        "additionalProperties": true
      }
    }
  }
}
